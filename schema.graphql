type Token @entity {
  id: ID!
  owner: Bytes!
  address: Bytes!
  name: String!
  symbol: String!
  decimals: Int!
  supply: BigInt! # currently minted (i.e. staked for)
  maxSupply: BigInt! # maximum that can be minted
  availableSupply: BigInt! # ~ token owner balance
  stake: BigInt!
  nav: Int
  kyaHash: Bytes
  kyaUrl: String

  isFrozen: Boolean!

  whitelist: [WhitelistedAccount!]! @derivedFrom(field: "token")
  greylist: [GreylistedAccount!]! @derivedFrom(field: "token")
  holders: [TokenHolder!]! @derivedFrom(field: "token")
  transferRequests: [TransferRequest!]! @derivedFrom(field: "token")
  transfers: [Transfer!]! @derivedFrom(field: "token")
  fundraisers: [Fundraiser!]! @derivedFrom(field: "token")
  currentFundraiser: Fundraiser
  transferRules: TransferRules
  features: Features
}

type WhitelistedAccount @entity {
  id: ID!
  address: Bytes!
  createdAt: BigInt!
  token: Token
}

type GreylistedAccount @entity {
  id: ID!
  address: Bytes!
  createdAt: BigInt!
  token: Token
}

# need to be able to find token for TransferRules events
type TransferRules @entity {
  id: ID!
  token: Token!
}

type Features @entity {
  id: ID!
  token: Token!

  forceTransfer: Boolean!
  tokenFreeze: Boolean!
  accountFreeze: Boolean!
  accountBurn: Boolean!
}

enum TransferRequestStatus {
  Pending,
  Approved,
  Denied,
}

type TransferRequest @entity {
  id: ID!
  token: Token!
  from: TokenHolder!
  to: TokenHolder!
  value: BigInt!
  status: TransferRequestStatus!
}

type Transfer @entity {
  id: ID!
  token: Token!
  from: TokenHolder!
  to: TokenHolder!
  value: BigInt!
}

type TokenHolder @entity {
  id: ID!
  token: Token!
  address: Bytes!
  balance: BigInt!
  createdAt: Int!
  updatedAt: Int!
  isFrozen: Boolean!
}

enum FundraiserStatus {
  SettingUp,
  Setup,
  Running,
  Finished,
  Canceled
}

type Fundraiser @entity {
  # from constructor
  id: ID!
  owner: Bytes!
  token: Token!
  label: String!
  startDate: Int!
  endDate: Int!
  softCap: BigInt!
  hardCap: BigInt!
  supply: BigInt! # aka tokensToMint
  # from setup
  baseCurrency: Bytes
  tokenPrice: BigInt
  affiliateManager: Bytes
  contributorRestrictions: Bytes
  minter: Bytes
  contributionsLocked: Boolean
  # computed
  amountQualified: BigInt!
  amountPending: BigInt!
  amountRefunded: BigInt!
  amountWithdrawn: BigInt!
  status: FundraiserStatus!
  contributors: [Contributor!] @derivedFrom(field: "fundraiser")
#  contributions: [Contribution!] @derivedFrom(field: "fundraiser")
}

enum ContributorStatus {
  Pending
  Qualified
  Removed
  Refunded
}

type Contributor @entity {
  id: ID!
  fundraiser: Fundraiser!
  status: ContributorStatus!
  address: Bytes!
  amount: BigInt!
  contributions: [Contribution!] @derivedFrom(field: "contributor")
}

# Bacause of the nature of stuff, we cannot update contributions from previous state or delete the ones with wrong state
# For that reason, we remember all of them and the app is responsible for filtering only those where
# contribution.type = contributor.status
type Contribution @entity {
  id: ID!
#  fundraiser: Fundraiser!
  contributor: Contributor!
  type: ContributorStatus!
  timestamp: Int!
  amount: BigInt!
}
